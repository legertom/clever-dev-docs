{
  "id": "sso-using-an-implicit-grant-01",
  "url": "https://dev.clever.com/docs/il-implicit-grant",
  "path": "/docs/il-implicit-grant",
  "section": "Discovered",
  "title": "SSO using an Implicit Grant",
  "heading": "SSO using an Implicit Grant",
  "headingLevel": 0,
  "parentHeadings": [
    "SSO using an Implicit Grant"
  ],
  "content": "This URL has a few component parts:\n\n-   the scheme/protocol (`https://`)\n-   the authority/host (`example.com`)\n-   the path (`/some/path`)\n-   the query string (`?field0=value0`)\n-   the URI fragment (`#field1=value1&field=value2`)\n\nTypically, a web server never receives a URI fragment. When you use a URL like this in a web browser, only `https://example.com/some/path?field0=value0` is received by the server. The URI fragment is instead handled by the web browser. Your application programmatically gains access to the URI fragment only when the web browser is executing client-side Javascript. This is why this implicit grant flow is typically used in client-side Javascript applications.\n\n## \n\nExtracting the token from the URI fragment\n\n[](#extracting-the-token-from-the-uri-fragment)\n\nThe OAuth 2.0 implicit grant flow specifies that Clever present you a series of `application/x-www-form-urlencoded` key/value pairs within the URI fragment. Your user agent (typically a web browser in this flow) is unlikely to provide you a direct way to convert that URI fragment string into an accessible data type, such as a Javascript associative array.\n\nYou'll need to use Javascript to evaluate the URI fragment string, extract the keys and values, and yield a traversable data structure. We recommend using an open source library to perform these extractions, such as [jQuery BBQ](http://benalman.com/projects/jquery-bbq-plugin/). However, the following snippet should be functional for most Clever purposes.\n\n```javascript\n// First, extract the URI fragment from the user agent's location object\nfunction extractParamsFromURIFragment() {\n  var fragmentParams = {};\n  var e,\n      a = /\\+/g,  // Regex for replacing addition symbol with a space\n      r = /([^&;=]+)=?([^&;]*)/g,\n      d = function (s) { return decodeURIComponent(s.replace(a, \" \")); },\n      q = window.location.hash.substring(1);\n\n  while (e = r.exec(q)) {\n    fragmentParams[d(e[1])] = d(e[2]);\n  }\n  return fragmentParams;\n}\n```\n\nUsing a similar function, you could extract the bearer token and state with code similar to:\n\n```javascript\nvar params = extractParamsFromURIFragment();\nvar bearer_token = params['access_token'];\nvar state = params['state'];\nvar scope = params['scope'];\n```\n\n## \n\nServer-side implications\n\n[](#server-side-implications)\n\nTypically your server will still receive a simple request to your specified `redirect_uri` even when you're handling it client-side.\n\nYou will not receive the data in the URI fragment and you should essentially treat these requests as a \"no-op.\" One reason to separate concerns with distinct redirect URIs is so you don't have to worry about triggering your typical server-side redirect with these requests.\n\n## \n\nIdentify bearer token authenticity with tokeninfo\n\n[](#identify-bearer-token-authenticity-with-tokeninfo)\n\nNow that you've gotten ahold of your user's bearer token, you'll use it in REST API requests to Clever's data API.\n\nBefore using the bearer token, it is important to verify the token's legitimacy. The implicit grant flow pushes bearer tokens in your application's direction but just because you've received a token doesn't mean it necessarily came from Clever or was intended for your specific application.\n\nTo protect against the \"[confused deputy problem](http://en.wikipedia.org/wiki/Confused_deputy_problem)\" and determine if the token is intended for your application and was produced by Clever, you must verify its authenticity and legitimacy by issuing an additional request to Clever.\n\nVerifying is simple. Issue a HTTP GET request to `https://clever.com/oauth/tokeninfo` and assert your bearer token and then validate the response.\n\nIf the bearer token received was `jsfUI2131da2f`, your HTTP Authorization header and request may look something like this:\n\n```\nGET https://clever.com/oauth/tokeninfo\nAuthorization: Bearer jsfUI2131da2f\n```\n\n### \n\nSuccess\n\n[](#success)\n\nIf the token was issued by Clever, you should receive a HTTP 200 response with a JSON body containing a `client_id` and the token's associated scopes. After receiving this response, compare the received `client_id` to the `client_id` associated with your application. If they are the same, proceed with storing the token and logging the user in to your application.\n\nA typical success response will looking something like:\n\n```\n{\n  \"client_id\": \"9122696a58e9c5ae3ad4\",\n  \"scopes\": [\n    \"read:user_id\",\n    \"read:teachers\",\n    \"read:students\"\n  ]\n}\n```\n\nIf the client\\_id does **not** match, discard the token and prevent the user from signing in.\n\n### \n\nRejection\n\n[](#rejection)\n\nIf the token was not issued by Clever, you should receive a HTTP 401 response. No need to evaluate the response's body — just knowing that it's a HTTP 401 should be enough for you to discard the token and prevent the user from signing in.\n\n### \n\nTechnical failure\n\n[](#technical-failure)\n\nIf Clever can't evaluate the token for some reason — usually due to some kind of internal error — we'll respond with a HTTP 500, HTTP 502, or HTTP 503 error. These errors don't necessarily imply the token is invalid, and you may want to retry the request or ask the user to attempt the login sequence again. Please use an exponential back off strategy if you intend to retry requests.\n\n## \n\nUse the bearer token to issue Data API requests\n\n[](#use-the-bearer-token-to-issue-data-api-requests)\n\nExactly as you would if you had obtained the token through the authorization grant flow\n\n## \n\nError Handling\n\n[](#error-handling)\n\nIn most cases, if there's a problem authorizing the end user or if you've constructed your `oauth/authorize` URL incorrectly, there's no programmatic error condition to consume. Clever will not redirect the user to your specified redirect URI and you'll simply be left with an initiated login state that is never consummated.",
  "tokenEstimate": 1462,
  "crawledAt": "2026-02-23T02:55:12.099Z",
  "chunkIndex": 1,
  "totalChunks": 3
}