{
  "id": "designing-district-sso-integrations-00",
  "url": "https://dev.clever.com/docs/il-design",
  "path": "/docs/il-design",
  "section": "Discovered",
  "title": "Designing District SSO Integrations",
  "heading": "Designing District SSO Integrations",
  "headingLevel": 0,
  "parentHeadings": [
    "Designing District SSO Integrations"
  ],
  "content": "Here we've outlined important design decisions to make when building your Instant Login integration. If you have any questions, reach out to [\\[email protected\\]](/cdn-cgi/l/email-protection#dfabbabcb7f2acaaafafb0adab9fbcb3baa9baadf1bcb0b2).\n\n## \n\nGeneral best practices:\n\n[](#general-best-practices)\n\n-   Don't prevent users with missing data from logging in\n-   Don't exchange code values multiple times\n-   Your application must allow users to log in when arriving from the Clever Portal or an Instant Login Link\n-   Your application's first defined redirect URI must handle logins for all districts without requiring additional parameters or subdomains. Use a centralized redirect URI to capture users, then send users to specialized domains and URLs as necessary.\n-   You must use HTTPS on your production user-facing redirect URI. The rest of your application should use HTTPS also.\n-   Your application should include a Log in with Clever button\n-   You should support district and school administrator login. If your application does not have a role for these user types, treat them like teachers.\n\n## \n\nProcessing authorization codes\n\n[](#processing-authorization-codes)\n\nYour application may receive the same `code` value multiple times. When Clever sends a user to a redirect URI, Clever loses control of what the browser and user may do with that redirect URI. The user or browser may visit the URL with the authorization code intact -- a single time or twice or a dozen times. This occurrence might be triggered by automatic browser behavior (like automatic page refreshing), or directly by the user utilizing their back button or a bookmarked link.\n\nThe web browser or user is typically unaware of the significance of the parameters associated with the request.\n\nIn OAuth 2.0, client applications are expected to ensure that they do not attempt to exchange an authorization code multiple times. ([\"The client MUST NOT use the authorization code more than once.\"](https://tools.ietf.org/html/rfc6749#section-4.1.2))\n\nSo, what do you do when you've already exchanged an authorization code that a user brings with them to your redirect URI?\n\nInstead of sending another request to `POST /oauth/tokens` with the repeat authorization, keep a history of recent `code` exchanges.\n\nYour applications could recall the authorization codes it has exchanged and for which user a code was exchanged. With this knowledge, application logic can be developed to prevent a client application from attempting to exchange a code value multiple times. From there, you have several options:\n\n## \n\n1\\. Resume the current user's session for the current user\n\n[](#1-resume-the-current-users-session-for-the-current-user)\n\nOne approach would be to maintain a short-lived mapping (in memcache, perhaps) of successfully exchanged code values and the user associated with the request.\n\nIf a valid session _for that same user_ is still active in the browser and they _have not_ initiated log out, your application could resume the already existing session. You would not attempt to exchange the recently used code value for a bearer token.\n\nYou may want to present the user with a \"you are already signed in\" message.\n\n## \n\n2\\. Ask the user to log in with Clever again\n\n[](#2-ask-the-user-to-log-in-with-clever-again)\n\nAnother approach would be to simply record a list of recently exchanged code values, and identify attempts to re-use authorization codes.\n\nInstead of resuming a user session, terminate any existing browser session, and direct the user to attempt signing in to the application again with a [Log in with Clever link](/docs/identity-api#section-liwc-button-assets).\n\nWhen the user clicks on the button, their Clever launchpad session will be resumed and they will be redirected to your application again, this time with a fresh code value.\n\n## \n\nProtecting against Cross-Site Request Forgery (CSRF)\n\n[](#protecting-against-cross-site-request-forgery-csrf)\n\nCSRF is a vulnerability that occurs when an attacker can cause a victim to perform an unintended action on a web resource. For more information, see [Keeping Instant Login Secure](/docs/il-security).\n\nThe best way to protect against CSRF vulnerabilities in OAuth 2 is to use a `state` parameter to verify that the user intends to make the login request to your app. The `state` parameter is a value managed by your app. To protect against CSRF, you must first generate the state parameter and associate it with the user - via their session, for instance - and then send it to Clever in the /oauth/authorize link. Clever will redirect the user to your redirect URI with a `code` and the `state` as provided. You should verify this `state` matches what is in the user’s session before exchanging the `code` for an access token.\n\n## \n\nProtecting Clever-initiated logins\n\n[](#protecting-clever-initiated-logins)\n\nBy default, Clever-initiated login links (such as those in the portal) do not use the `state` parameter. It isn’t feasible to include a `state` parameter in these types of links, since your application must generate this value and associate it with the user using a channel protected by the same-origin policy. However, you may choose to “re-redirect” back to Clever, while adding the `state` parameter with these links.\n\nUsing this approach, you would simply ignore the code parameter to your redirect URI unless the `state` parameter is also present. If it isn’t, you would set the `state` parameter and redirect back to /oauth/authorize. The final redirect back to your app would contain the `state` parameter, which you could verify before initiating the code exchange.\n\n## \n\nProtecting Application-initiated logins\n\n[](#protecting-application-initiated-logins)",
  "tokenEstimate": 1433,
  "crawledAt": "2026-02-23T03:17:17.465Z",
  "fetchMethod": "static",
  "chunkIndex": 0,
  "totalChunks": 3
}