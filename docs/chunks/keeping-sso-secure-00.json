{
  "id": "keeping-sso-secure-00",
  "url": "https://dev.clever.com/docs/il-security",
  "path": "/docs/il-security",
  "section": "Clever SSO",
  "title": "Keeping SSO Secure",
  "heading": "Keeping SSO Secure",
  "headingLevel": 0,
  "parentHeadings": [
    "Keeping SSO Secure"
  ],
  "content": "## \n\nPreventing Cross-Site Request Forgery\n\n[](#preventing-cross-site-request-forgery)\n\nCross-Site Request Forgery (CSRF) is a vulnerability that occurs when an attacker can cause a victim to perform an unintended action on a web resource. In the context of SSO, CSRF vulnerabilities can allow an attacker to force a victim to log in to an app using the attacker’s identity.\n\nFor example, an attacker could generate an SSO link for their account and then put it in the source attribute of an image of a web page. They would then force a victim to visit this page, who would unknowingly make a request to clever.com with their existing session, which would log them in with the attackers account to the application in question.\n\n`<img src=\"https://clever.com/oauth/authorize?type=code&client_id=123456\">`\n\nDepending on the configuration of the application, this may result in a low impact threat (\"the victim is logged in to the application as the attacker and may accidentally type in sensitive data\") or a high impact threat (\"the attacker’s identity is silently added to the victim’s account in the application\").\n\nFor more information on this threat, see [this blog post](http://homakov.blogspot.com/2012/07/saferweb-most-common-oauth2.html). For information on protecting your integration against CSRF, see [Designing Your Integration](/docs/il-design).\n\n  \n\n## \n\nShared Devices: Session Re-authentication and Session Invalidation\n\n[](#shared-devices-session-re-authentication-and-session-invalidation)\n\nTo protect user data and maintain secure access on shared devices, it is crucial to implement **session re-authentication** and **session invalidation** mechanisms. These practices help ensure that user sessions are properly terminated when switching users, preventing unauthorized access to sensitive information. This guide outlines best practices for implementing these features.\n\n* * *\n\n#### \n\n1\\. **Session Re-authentication**: Ensuring Secure Access Transitions\n\n[](#1-session-re-authentication-ensuring-secure-access-transitions)\n\nSession re-authentication requires the user to **re-authenticate** when necessary, such as after a certain period of inactivity or when switching users on shared devices. Re-authentication ensures that the current user is the rightful owner of the session, preventing unintended access to the data of previously authenticated users.\n\n##### \n\nKey Implementation Steps:\n\n[](#key-implementation-steps)\n\n-   **Prompt Re-authentication on User Switch**: Ensure that when a new user attempts to access the application, the existing session is invalidated, and the new user is required to log in. This ensures that only the new user’s session is active on the device.\n-   **Set Short Session Expiration Times**: On shared devices, set **short session expiration times** to minimize the risk of unauthorized access. After a period of inactivity, prompt the user to re-authenticate.\n-   **Multi-Factor Authentication (MFA)**: For enhanced security, consider implementing **MFA** during re-authentication. This ensures that even if the device is shared, only authorized users can regain access to the session.\n\n* * *\n\n#### \n\n2\\. **Session Invalidation**: Terminating Previous Sessions on Shared Devices\n\n[](#2-session-invalidation-terminating-previous-sessions-on-shared-devices)\n\nSession invalidation is critical for ensuring that **only one session is active per user**. If a new session is initiated (e.g., via a new login or user switch), the previous session must be terminated to avoid security risks associated with concurrent sessions on shared devices.\n\n##### \n\nKey Implementation Steps:\n\n[](#key-implementation-steps-1)\n\n-   **Invalidate Old Sessions**: Implement logic to **invalidate all active sessions** when a new authentication occurs. This ensures that no other active session remains after the user logs in from a new instance, device, or browser.\n-   **Clear Session Data Upon Logout**: On logout, ensure that all session-related data (such as cookies or local storage) is cleared, preventing session data from being reused inappropriately.\n-   **Immediate Revocation**: Use **immediate token revocation** to ensure that once a session is invalidated, it cannot be used for any further requests.\n\n* * *\n\n#### \n\n3\\. **Best Practices for Securing Shared Devices**:\n\n[](#3-best-practices-for-securing-shared-devices)\n\n-   **Monitor and Limit Concurrent Sessions**: Implement policies that **limit the number of concurrent sessions** a user can have. If a user logs in on a shared device, any other active sessions should be revoked.\n-   **Graceful Logout**: Provide a clear and **visible logout option** for users on shared devices, encouraging users to end their session when finished.\n-   **Audit and Logging**: Log user activities and session invalidation events to detect unusual behavior, such as multiple session creation or failed login attempts.\n\n* * *\n\n#### \n\n4\\. **Security Considerations**:\n\n[](#4-security-considerations)\n\n-   **Use Secure Cookies**: Store session data in **HTTP-only and secure cookies** to prevent unauthorized access via cross-site scripting (XSS) attacks.\n-   **Implement HTTPS**: Ensure that all sessions and authentication tokens are transmitted over **HTTPS** to protect against man-in-the-middle attacks.\n-   **Token Expiration and Rotation**: Implement **short-lived access tokens** and **automatic token rotation** to ensure that session tokens do not persist longer than necessary.\n\n* * *",
  "tokenEstimate": 1370,
  "crawledAt": "2026-02-23T02:59:57.350Z",
  "fetchMethod": "static",
  "chunkIndex": 0,
  "totalChunks": 1
}